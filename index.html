<html>
<head>
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
</head>
<style type="text/css">

	svg {
		font-family: "Helvetica Neue", Helvetica;
	}

	line {
		shape-rendering: crispEdges;
		vector-effect: non-scaling-stroke;

		stroke: #000;
		stroke-width: 2px;
	}

	circle {
		shape-rendering: crispEdges;
		vector-effect: non-scaling-stroke;
		stroke: steelblue;
		stroke-width: 1.5px;
	}

	circle:hover {
		cursor: pointer;
	}

	circle.active-d3-item {
		fill: red;
	}
	
	text {
		transform: translate(0px, 15px);
		cursor:  pointer;
	}

</style>
<body>
	<div class="container" style="margin-top:10px; text-align:right">
		<button id="back" onclick="backTo()">Back</button>
		<button id="home" onclick="backToHome()">Home</button>
	</div>
	<div id="my_dataviz"></div>
	<svg width="1000px"; height="1000px";></svg>
	<script>

		var width = 1000; 
		//var rad = 5;
		var ydist = 25;
		var xdist = 20;
		var svg = d3.select('svg');
		var xDefault = 20;
		var yDefault = 40;

		var edges = [];
		var edgesCluster = [];
		var nodes = [];
		var dic = [];
		var coordinates = [];
		var coordinatesOld = [];
		var dict= {}
		var level = 0;
		
		function backToHome(){		
			d3.select('#home').style("visibility", "hidden")
			d3.select('#back').style("visibility", "hidden")
			graphGen(edgesCluster);
		}
		
		function backTo(){
			if (dict.level == 0) {
				level = 0;
				dict.level -= 1
				backToHome()
			} else if(dict.level == 1) {
				level = 0;
				dict.level -= 1
				backToHome()
			} 
			else if(dict.level == 2) {
				level -= 1
				dict.level -= 1
				draw(dict.coordinatesPrec)
			}
		}

		// logaritmo base x di y
		function getBaseLog(x, y) {
			if(y!=0){
  				log = Math.log(y) / Math.log(x);
  				return Math.floor(log);
  			}
  			return 0;
  		}

		// genera un id univoco simile all'hash
		function makeID(seed){
			return uuidv4()+seed;
		}

		//genera un id
		function uuidv4() {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
				var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
				return v.toString(16);
			});
		}

		//funzione che resetta il contatore son
		function resetSon(){
			nodes.forEach(nodo => {
				nodo.son = nodo.sonCount;
			});
		}

		// funzione che dati due nodi in ingresso (n1 padre e n2 figlio) 
		// setta le coordinate di n2 per la rappresentazione
		function setXY(n1, n2){
			let x1lenMez = 0;
			let x2lenMez = ((getBaseLog(2, n2.nodi.length)*10)+20)/2;
			let varX = x2lenMez;
			let directionLR = true;
			let d = xDefault+x2lenMez;  //valore di default
			let h = yDefault;  //valore di default
			//se il padre del nodo esiste (nodi diversi dal primo)
			if(n1){
				d = n1.x;
				h = n1.y;
				directionLR = n1.directionLR;
				n2.directionLR = n1.directionLR;
				x1lenMez = ((getBaseLog(2, n1.nodi.length)*10)+20)/2;
			}

			// se mi sposto da sinistra a destra incremento x
			if (directionLR) {
				varX = d;
				if(n1){
					varX = d+x1lenMez+xdist+x2lenMez;
				}
			}
			// altrimento la decremento
			else {
				varX = d;  // se n1 non esiste è un errore, questa rappresentazione lo evidenzia
				if(n1){
					varX = d-(x1lenMez+xdist+x2lenMez);
				}
			}

			// se supero il limite destro scendo verticalmente e cambio verso di marcia
			if ((varX+x2lenMez)>=width) {
				h = h+ydist;
				varX = width-xDefault-x2lenMez;
				n2.directionLR = false;
				n1.border = 1;
			}
			// stressa cosa se raggiungo il limite sinistro
			else if ((varX-x2lenMez)<=10) {
				n2.directionLR = true;
				h = h+ydist;
				varX = xDefault+x2lenMez;
				n1.border = 1;
			}
			// se sono un secondo figlio sul bordo ignoro il cambio di marcia
			else if (n1&&((!directionLR&&(varX+x2lenMez+xDefault)>=width)||(directionLR&&(varX-(x2lenMez+xDefault)<=10) && n1.prev_block!=""))) {
				if (n1.border==1){
					h = h+ydist;
				}
			}

			let varY = h;
			if(n1&&n1.son>1){
				varY = (h+ydist);
			}
			n2.y = varY; 
			n2.x = varX;
			if(!n1){
				n1 = n2;
			}
			else{
				n1.son -= 1;
			}
			let nodi = n2.nodi;
			let archi = n2.archi;
			return {
				x2: varX,
				y2: varY,
				x1: n1.x,
				y1: n1.y,
				nodi1: n1.nodi,
				archi1: n1.archi,
				hash1: n1.hash,
				nodi2: nodi,
				archi2: archi,
				hash2: n2.hash,
				border1: n1.border,
				border2: n2.border,
				dir2: n2.directionLR,
				height: n2.height
			}
		}

		// funzione che crea un arco a partire dai valori hash di un blocco dato 
		// in ingresso e inserisce l'arco in edges ed il blocco in nodes
		function createEdges(block){
			if (block.prev_block!=""){
				let id = makeID(block.prev_block+block.hash);
				let edge = {"hashFrom": block.prev_block, "hashTo": block.hash, "id": id};
				if (getNode(edge,0)!=null){
					getNode(edge,0).son += 1;
					getNode(edge,0).sonCount += 1;
				};
				edges.push(edge);
			}
			nodes.push({"prev_block": block.prev_block, "hash": block.hash, "height": block.height, "x":xDefault, "y":yDefault, "son":0, "sonCount":0, "border":0, "cluster":0, "nodi":[], "archi":[], "directionLR": true})
		}

		// dato un arco e la posizione 0 o 1 ritorna il nodo in tale posizione
		function getNode(edge, position){
			let n = null;
			if (position==0){
				n = nodes.filter(node => node.hash == edge.hashFrom);
			}
			else{
				n = nodes.filter(node => node.hash == edge.hashTo);
			}
			return n[0];
		}

		// dato un nodo ritorna l'arco o gli archi (list) che contengono 
		// tale nodo come padre
		function getEdge(node){
			if (node){
				e = edges.filter(edge => edge.hashFrom == node.hash);
				return e;
			}
			else return null;
		}

		// dato un nodo genera una lista di tutti i nodi colegatti a questo 
		// fino ad arrivare ad una biforcazione
		function nodiConsecutivi(node, list){
			if (node.sonCount <= 1){
				list.push(node);
				let edge = getEdge(node)[0];
				if (edge){
					let son = getNode(edge, 1);
					if (son){
						let x = nodiConsecutivi(son, list);
						return x;
					}
				}
				else{
					return node;
				}
			}
			else{
				list.push(node); // l'ultimo nodo della lista è il padre dello split
				return node;
			}
		}

		// data una lista ordinata di nodi ed un nodo in testa a cui attaccare gli 
		// altri genera una lista degli archi che collegano tali nodi
		function generaArchi(blockList, firstPrevBlock){
			var resultList = [];
			let pred = firstPrevBlock;
			let length = blockList.length;
			for(let i=0; i<length; i++){
				let id = makeID(blockList[i].hash);
				let e = {"hashFrom": pred, "hashTo": blockList[i].hash, "id": id};
				resultList.push(e);
				pred = blockList[i].hash;
			}
			return resultList;
		}

		function generaSottoCluster(list, id){
			let returnList = [];
			let l = list.length;
			while(l>0){
				let expClust = Math.floor(getBaseLog(2, l));
				let sizeClust = 2**expClust;
				l -= sizeClust;
				let id1 = makeID(Math.random()*1000000000000000000);
				var node = {"prev_block": 0, "hash": id1, "height": -1, "x":xDefault+50, "y":yDefault, "son":0, "sonCount":1, "border":0, "cluster":1, "nodi":[], "archi":[], "directionLR": true};
				let listArchi = [];
				let listNodi = [];
				while(sizeClust>0){
					sizeClust -= 1;
					let t = list.shift();
					listNodi.push(t);
				}
				node.nodi = listNodi;
				listArchi = generaListArchiFromNodi(listNodi, id)
				node.archi = listArchi;returnList.push(node);
				nodes.push(node);
			}
			return returnList;
		}

		function generaListArchiFromNodi(listaNodi, id){
			let listNodi = [...listaNodi];  // lista di appoggio
			let listInput = [...listaNodi];
			if(listNodi.length>2**6){
				listInput = [];
				let split = Math.sqrt(listNodi.length);
				let intSplit = Math.floor(split);
				while(listNodi.length>0){
					let tmpList = [];
					let tmpSplit = intSplit;
					while(tmpSplit>0&&listNodi.length>0){
						tmpSplit -= 1;
						let t = listNodi.shift();
						tmpList.push(t);
					}
					let cluster = generaSottoCluster(tmpList, id+1);
					listInput = listInput.concat(cluster);
				}
			}
			let tmpList = generaArchi(listInput, "firstPrevBlock");
			c = tmpList.shift();
			if(c.hashFrom!="firstPrevBlock"){
				console.log("errore rimozione primo arco");
			}
			return tmpList;
		}

		// data una lista di nodi genera i nodi cluster con il metodo dell'esponenziale, 
		// li inserisce in nodes e ritorna una lista con gli archi che collegano tali nodi cluster
		function valutaLista(list, id){
			let tempList = [];
			let l = list.length-1;
			let firstPrevBlock = list[0].prev_block;
			while (l>1){
				let expClust = Math.floor(getBaseLog(2, l));
				let sizeClust = 2**expClust;
				l -= sizeClust;
				let id1 = makeID(list[0].hash);
				var node = {"prev_block": 0, "hash": id1, "height": -1, "x":xDefault, "y":yDefault, "son":0, "sonCount":1, "border":0, "cluster":1, "nodi":[], "archi":[], "directionLR": true};
				let listArchi = [];
				let listNodi = [];
				while(sizeClust>0){
					sizeClust -= 1;
					let t = list.shift();
					listNodi.push(t);
				}
				node.nodi = listNodi;
				listArchi = generaListArchiFromNodi([...listNodi], id);
				node.archi = listArchi;
				tempList.push(node);
				nodes.push(node);
			}
			l = list.length;
			while(l>0){
				t = list.shift();
				tempList.push(t);
				l = l-1;
			}
			let arc = generaArchi(tempList, firstPrevBlock);
			return arc;
		}

		// dato il nodo iniziale scorre ricorsivamente il grafo, genera i cluster 
		// e ritorna la lista degli archi dei cluster generati
		function createClusterDic(node, id){
			let list = [];
			var archiCluster = [];
			let n = nodiConsecutivi(node, list);
			archiCluster = valutaLista(list, id);
			let ed = getEdge(n);
			let archiTmp = [];
			if (ed){
				ed.forEach(arco => {
					let b = getNode(arco, 1);
					archiTmp = createClusterDic(b, id+1);
					archiCluster = archiCluster.concat(archiTmp);
				});
			}
			return archiCluster;
		}

		// funzione di inizializzazione archi
		function init(archi){
			first = nodes.filter(node => node.prev_block == "")[0];
			var archiCluster = [];
			archiCluster = createClusterDic(first, 0); //deve ritornare archiCluster
			edgesCluster = archiCluster;
			graphGen(edgesCluster);
		}

		// generazione del grafo dagli archi passati
		function graphGen(archi){
			resetSon();
			let i = 0;
			if (coordinates) {
				coordinatesOld = coordinates;
			}
			coordinates = archi.map(function(edge){
				i++;
				n1 = getNode(edge, 0);
				n2 = getNode(edge, 1);
				return setXY(n1, n2);
			});
			dict = {"coordinatesStart": edgesCluster, "coordinatesPrec": coordinatesOld, "level": level++}
			draw(coordinates);
		}

		var data = d3.json("blockchain.json", function(data) {

			var dataSet = data.blocks.map(function(block) {
				d = block.height;
				createEdges(block);
			});

			init(edges);  // passo edges per la rappresentazione di default	ma poi lo ignoro

		});

		function getX1(d){
			let l = d.x1-10;
				if(d.border1==0){
					if(d.x1<d.x2){
						if(getBaseLog(2, d.nodi1.length)==0){
							l = d.x1+10;
						}
						else{
							l = d.x1+((10*getBaseLog(2, d.nodi1.length)+20)/2)-10;
						}
					}
					else{
						if(getBaseLog(2, d.nodi1.length)==0){
							l = d.x1-10;
						}
						else{
							l = d.x1-((10*getBaseLog(2, d.nodi1.length)+20)/2)-10;
						}
					}
				}
				else if(d.dir2&&(d.x1-((10*getBaseLog(2, d.nodi1.length)+20)/2)-10)>d.x2){

					l = d.x1-((10*getBaseLog(2, d.nodi1.length)+20)/2)-10;
				}
				else if(!d.dir2&&(d.x1+((10*getBaseLog(2, d.nodi1.length)+20)/2)-10)<d.x2){
					
					l = d.x1+((10*getBaseLog(2, d.nodi1.length)+20)/2)-10;
				}
			return l;
		}

		function getX2(d){
			let l = d.x2-10;
				if(d.border1==0){
					if(d.x1<d.x2){
						if(getBaseLog(2, d.nodi2.length)==0){
							l = d.x2-10;
						}
						else{
							l = d.x2-((10*getBaseLog(2, d.nodi2.length)+20)/2)-10;
						}
					}
					else{
						if(getBaseLog(2, d.nodi2.length)==0){
							l = d.x2+10;
						}
						else{
							l = d.x2+((10*getBaseLog(2, d.nodi2.length)+20)/2)-10;
						}
					}
				}
			return l;
		}

		function draw(data){
		
		if (level > 1) {
			d3.select('#home').style("opacity", 1)
			d3.select('#back').style("opacity", 1)
		} else {
			d3.select('#home').style("opacity", 0)
			d3.select('#back').style("opacity", 0)
		}
			
			// Generating the svg lines attributes
			var lineAttributes = {
				'x1': function(d) {
					return getX1(d);
				},
				'y1': function(d) {
					if(d.border1==1){
						if(d.dir2&&(d.x1-((10*getBaseLog(2, d.nodi1.length)+20)/2)-10)>d.x2){
							return d.y1;
						}
						else if(!d.dir2&&(d.x1+((10*getBaseLog(2, d.nodi1.length)+20)/2)-10)<d.x2){
							return d.y1;
						}
						return d.y1+10;
					}
					return d.y1;
				},
				'x2': function(d) {
					return getX2(d);
				},
				'y2': function(d) {
					if(d.border1==1){
						return d.y2-10;
					}
					return d.y2;
				},
				'nodi1': function(d) {
					return getBaseLog(2, d.nodi1.length);
				},
				'archi1': function(d) {
					return d.archi1;
				},
				'hash1': function(d) {
					return d.hash1;
				},
				'nodi2': function(d) {
					return getBaseLog(2, d.nodi2.length);
				},
				'archi2': function(d) {
					return d.archi2;
				},
				'hash2': function(d) {
					return d.hash2;
				},
				'height': function(d) {
					return d.height;
				}
			};


			// create a tooltip
		  var tooltip = d3.select("#my_dataviz")
			.append("div")
			.style("opacity", 0)
			.attr("class", "tooltip")
			.style("background-color", "white")
			.style("border", "solid")
			.style("position", "absolute")
			.style("border-width", "1px")
			.style("border-radius", "5px")
			.style("padding", "5px")


			// Pointer to the d3 lines
			var lines = svg
			.selectAll('.line')
			.data(data);

			lines.exit().remove();

			lines.enter()
			.append('line')
			.attr("class", "line")
			.attr(lineAttributes);

			lines.attr(lineAttributes);

			var topEndPoints = data.map(function(line, i) {
				return {
					'x': line.x1,
					'y': line.y1,
					'marker': 'marker-start',
					'lineIndex': i,
					'nodi': getBaseLog(2, line.nodi1.length),
					'archi': line.archi1,
					'hash': line.hash1,
					'height': line.height
				};
			});

			var bottomEndPoints = data.map(function(line, i) {
				return {
					'x': line.x2,
					'y': line.y2,
					'marker': 'marker-end',
					'lineIndex': i,
					'nodi': getBaseLog(2, line.nodi2.length),
					'archi': line.archi2,
					'hash': line.hash2,
					'height': line.height
				};
			});

			var endPointsData = topEndPoints.concat(bottomEndPoints);
			var circle = [topEndPoints[0]].concat(bottomEndPoints);

			// Generating the svg circle attributes
			var endPointsAttributtes = {
				'width': function(d) {
					if(d.nodi==0){
						return 20;
					}
					else{
						let l = 20+((d.nodi)*10);
						return l;
					}
				},
				'height': 20,
				'x': function(d) {
					if(d.nodi==0){
						return d.x-10;
					}
					return d.x-(20+((d.nodi)*10)/2);
				},
				'y': function(d) {
					return d.y-10;
				},
				'fill': function(d) {
					if(d.nodi==0){
						return 'lightsalmon';
					}
					else{
						return 'lightsteelblue';
					}
				} 
			};

			// Pointer to d3 rect
			var endPoints = svg
			.selectAll('.rect')
			.data(circle);

			endPoints.exit().remove();

			endPoints.enter()
			.append('rect')
			.attr("class", "rect")
			.attr(endPointsAttributtes)
			.on("mouseover", handleMouseOver)
			.on("mousemove", handleMouseOver)
			.on("mouseout", handleMouseOut)
			.on("click", showCluster);

			endPoints.attr(endPointsAttributtes);

			// testo
			var endPointsText = svg
			.selectAll('.text')
			.data(circle);

			//rimozione
			endPointsText.exit().remove();

			//creazione
			endPointsText.enter()
			.append('text')
			.attr("class", "text")
			.attr("text-anchor", "middle")
			.text(function(d){
				if(d.nodi==0){
					return "B";
				}
				else{
					return "";
				}
			})
			.attr('x', function(d){
				return d.x;
			})
			.attr('y', function(d){
				return d.y-10;
			})
            .attr('fill', 'black')
			.on("mouseover", handleMouseOver)
			.on("mousemove", handleMouseOver)
			.on("mouseout", handleMouseOut)
			.on("click", showCluster);

            //aggiornamento
			endPointsText.text(function(d){
				if(d.nodi==0){
					return "B";
				}
				else{
					return "";
				}
			})
			.attr('x', function(d){
				return d.x;
			})
			.attr('y', function(d){
				return d.y-10;
			});
			
			function handleMouseOver(d, i) {
			   if (d.nodi > 0) {
				  tooltip
				  .style("opacity", 1)		// Add interactivite
				  .html("I nodi nel cluster sono: 2^" + d.nodi)
				  // It is important to put the +XX: other wise the tooltip is 
				  // exactly where the point is an it creates a weird effect
				  .style("left", (d3.mouse(this)[0]+35) + "px") 
				  .style("top", (d3.mouse(this)[1]+10) + "px")
			  } else {
				  tooltip
				  .style("opacity", 1)		// Add interactivite
				  .html("Height: " + d.height + "<br>" + "Hash: " + d.hash)
				  // It is important to put the +XX: other wise the tooltip is 
				  // exactly where the point is an it creates a weird effect
				  .style("left", (d3.mouse(this)[0]+35) + "px") 
				  .style("top", (d3.mouse(this)[1]+10) + "px")
			  }
			 }
				  
			function handleMouseOut(d, i) {		
				tooltip
				  .style("opacity", 0)
		    }

		    function showCluster(d, i) {
		    	d3.select("#t" + d.x + "-" + d.y + "-" + i).remove();
		    	if(d.nodi>0){
		    		graphGen(d.archi);
		    	}
		    }
		};

	</script>
</body>
</html>
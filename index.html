<html>
<head>
	<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
</head>
<style type="text/css">

	svg {
		font-family: "Helvetica Neue", Helvetica;
	}

	line {
		shape-rendering: crispEdges;
		vector-effect: non-scaling-stroke;

		stroke: #000;
		stroke-width: 2px;
	}

	circle {
		shape-rendering: crispEdges;
		vector-effect: non-scaling-stroke;
		stroke: steelblue;
		stroke-width: 1.5px;
	}

	circle:hover {
		cursor: pointer;
	}

	circle.active-d3-item {
		fill: red;
	}

</style>
<body>
	<div class="container" style="margin-top:10px; text-align:right">
		<button onclick="backToHome()">Home</button>
	</div>
	<svg width="1000px"; height="1000px";></svg>
	<script>

		var width = 1000; 
		var rad = 5;
		var ydist = 25;
		var xdist = 30;
		var svg = d3.select('svg');
		var xDefault = 20;
		var yDefault = 40;

		var directionLR = true;
		var edges = [];
		var edgesCluster = [];
		var nodes = [];
		var dic = [];

		function backToHome(){
			graphGen(edgesCluster);
		}

		// logaritmo base x di y
		function getBaseLog(x, y) {
  			return Math.log(y) / Math.log(x);
		}

		// genera un id univoco di lunghezza simile all'hash
		function makeID(seed){
			var timestamp = new Date().valueOf();
			idBase = 1000000000000000000;
			return timestamp+idBase+seed;
		}

		function resetSon(){
			nodes.forEach(nodo => {
				nodo.son = nodo.sonCount;
			});
		}

		// funzione che dati due nodi in ingresso (n1 padre e n2 figlio) 
		// setta le coordinate di n2 per la rappresentazione
		function setXY(n1, n2){
			//console.log("n1",n1);
			//console.log("n2",n2);
			let varX = 0;
			let d = xDefault;  //valore di default
			if(n1){
				d = n1.x;
			}
			let h = yDefault;  //valore di default
			if(n1){
				h = n1.y;
			}

			// se mi sposto da sinistra a destra incremento x
			if (directionLR) {
				varX = d+xdist;
			}
			// altrimento la decremento
			else {
				varX = d-xdist;
			}

			// se supero il limite destro scendo verticalmente e cambio verso di marcia
			if (varX>=width) {
				h = h+ydist;
				varX = d;
				directionLR = false;
				n1.border = 1;
			}
			// stressa cosa se raggiungo il limite sinistro
			else if (varX<=10) {
				directionLR = true;
				h = h+ydist;
				varX = d;
				n1.border = 1;
			}
			// se sono un secondo figlio sul bordo ignoro il cambio di marcia
			else if (n1&&(!directionLR&&(varX+(xdist*2))>=width)||n1&&(directionLR&&(varX-(xdist*2)<=10) && n1.prev_block!="")) {
				if (n1.border==1){
					h = h+ydist;
				}
			}

			let varY = h;
			if(n1&&n1.son>1){
				varY = (h+ydist);
			}
			n2.y = varY; 
			n2.x = varX;
			if(!n1){
				n1 = n2;
			}
			else{
				n1.son -= 1;
			}
			return {
				x2: varX,
				y2: varY,
				x1: n1.x,
				y1: n1.y,
				nodi: n2.nodi.length,
				archi: n2.archi
			}
		}

		// funzione che crea un arco a partire dai valori hash di un blocco dato 
		// in ingresso e inserisce l'arco in edges ed il blocco in nodes
		function createEdges(block){
			if (block.prev_block!=""){
				let id = makeID(block.prev_block+block.hash);
				let edge = {"hashFrom": block.prev_block, "hashTo": block.hash, "id": id};
				if (getNode(edge,0)!=null){
					getNode(edge,0).son += 1;
					getNode(edge,0).sonCount += 1;
				};
				edges.push(edge);
			}
			nodes.push({"prev_block": block.prev_block, "hash": block.hash, "height": block.height, "x":xDefault, "y":yDefault, "son":0, "sonCount":0, "border":0, "cluster":0, "nodi":[], "archi":[]})
		}

		// dato un arco e la posizione 0 o 1 ritorna il nodo in tale posizione
		function getNode(edge, position){
			let n = null;
			if (position==0){
				n = nodes.filter(node => node.hash == edge.hashFrom);
			}
			else{
				n = nodes.filter(node => node.hash == edge.hashTo);
			}
			return n[0];
		}

		// dato un nodo ritorna l'arco o gli archi (list) che contengono 
		// tale nodo come padre
		function getEdge(node){
			if (node){
				e = edges.filter(edge => edge.hashFrom == node.hash);
				//console.log(e[0]);
				return e;
			}
			else return null;
		}

		// dato un nodo genera una lista di tutti i nodi colegatti a questo 
		// fino ad arrivare ad una biforcazione
		function nodiConsecutivi(node, list){
			if (node.sonCount <= 1){
				//console.log("dentro l'if");
				list.push(node);
				let edge = getEdge(node)[0];
				if (edge){
					let son = getNode(edge, 1);
					if (son){
						let x = nodiConsecutivi(son, list);
						return x;
					}
				}
				else{
					return node;
				}
			}
			else{
				list.push(node); // l'ultimo nodo della lista Ã¨ il padre dello split
				return node;
			}
		}

		// data una lista ordinata di nodi ed un nodo in testa a cui attaccare gli 
		// altri genera una lista degli archi che collegano tali nodi
		function generaArchi(blockList, firstPrevBlock){
			//console.log("tempList", blockList);
			//console.log("firstPrevBlock", firstPrevBlock);
			var resultList = [];
			let pred = firstPrevBlock;
			let length = blockList.length;
			for(let i=0; i<length; i++){
				let id = makeID(blockList[i].hash);
				let e = {"hashFrom": pred, "hashTo": blockList[i].hash, "id": id};
				resultList.push(e);
				pred = blockList[i].hash;
			}
			return resultList;
		}

		function generaListArchiFromNodi(listNodi){
			tmpList = generaArchi(listNodi, "firstPrevBlock");
			c = tmpList.shift();
			if(c.hashFrom!="firstPrevBlock"){
				console.log("errore rimozione primo arco");
			}
			return tmpList;
		}

		// data una lista di nodi genera i nodi cluster con il metodo dell'esponenziale, 
		// li inserisce in nodes e ritorna una lista con gli archi che collegano tali nodi cluster
		function valutaLista(list, id){
			//console.log(list);
			let tempList = [];
			let l = list.length-1;
			let firstPrevBlock = list[0].prev_block;
			while (l>1){
				let expClust = Math.floor(getBaseLog(2, l));
				//console.log(expClust);
				let sizeClust = 2**expClust;
				//console.log(sizeClust);
				l -= sizeClust;
				let id = makeID(list[0].hash);
				var node = {"prev_block": 0, "hash": id, "height": -1, "x":xDefault, "y":yDefault, "son":0, "sonCount":1, "border":0, "cluster":1, "nodi":[], "archi":[]};
				let listArchi = [];
				let listNodi = [];
				while(sizeClust>0){
					sizeClust -= 1;
					let t = list.shift();
					//node.nodi.push(t);
					listNodi.push(t);
				}
				node.nodi = listNodi;
				listArchi = generaListArchiFromNodi(listNodi);
				node.archi = listArchi;
				//console.log(node);
				tempList.push(node);
				nodes.push(node);
			}
			l = list.length;
			//console.log(tempList);
			while(l>0){
				t = list.shift();
				tempList.push(t);
				l = l-1;
			}
			let arc = generaArchi(tempList, firstPrevBlock);
			//console.log("arc",arc, id);
			return arc;
		}

		// dato il nodo iniziale scorre ricorsivamente il grafo, genera i cluster 
		// e ritorna la lista degli archi dei cluster generati
		function createClusterDic(node, id){
			let list = [];
			var archiCluster = [];
			let n = nodiConsecutivi(node, list);
			//console.log("list",list);
			archiCluster = valutaLista(list, id);
			let ed = getEdge(n);
			let archiTmp = [];
			if (ed){
				//console.log(ed);
				ed.forEach(arco => {
					let b = getNode(arco, 1);
					//console.log("sono dentro", b, id);
					archiTmp = createClusterDic(b, id+1);
					//console.log("archiTmp", archiTmp, id);
					archiCluster = archiCluster.concat(archiTmp);
				});
			}
			//console.log("archiCluster-interno", archiCluster, id);
			return archiCluster;
		}

		// funzione di inizializzazione archi
		function init(archi){
			first = nodes.filter(node => node.prev_block == "")[0];
			//console.log(first);
			var archiCluster = [];
			archiCluster = createClusterDic(first, 0); //deve ritornare archiCluster
			edgesCluster = archiCluster;
			//graphGen(archi);
			graphGen(edgesCluster);
			console.log("archi", archi);
			console.log("archiCluster", archiCluster);
		}

		// generazione del grafo dagli archi passati
		function graphGen(archi){
			resetSon();
			var coordinates = archi.map(function(edge){
				n1 = getNode(edge, 0);
				n2 = getNode(edge, 1);
				return setXY(n1, n2);
			});
			console.log("coordinates",coordinates);
			draw(coordinates);
		}

		var data = d3.json("blockchain.json", function(data) {
			//console.log(data);

			var dataSet = data.blocks.map(function(block) {
				d = block.height;
				createEdges(block);
			});

			init(edges);  // passo edges per la rappresentazione di default	ma poi lo ignoro

		});

		function draw(data){
			// Generating the svg lines attributes
			var lineAttributes = {
				'x1': function(d) {
					return d.x1;
				},
				'y1': function(d) {
					return d.y1;
				},
				'x2': function(d) {
					return d.x2;
				},
				'y2': function(d) {
					return d.y2;
				},
				'nodi': function(d) {
					return d.nodi;
				},
				'archi': function(d) {
					return d.archi;
				}
			};

			// Pointer to the d3 lines
			var lines = svg
			.selectAll('.line')
			.data(data);

			lines.exit().remove();

			lines.enter()
			.append('line')
			.attr("class", "line")
			.attr(lineAttributes);

			lines.attr(lineAttributes);

			var topEndPoints = data.map(function(line, i) {
				return {
					'x': line.x1,
					'y': line.y1,
					'marker': 'marker-start',
					'lineIndex': i,
					'nodi': line.nodi,
					'archi': line.archi
				};
			});

			var bottomEndPoints = data.map(function(line, i) {
				return {
					'x': line.x2,
					'y': line.y2,
					'marker': 'marker-end',
					'lineIndex': i,
					'nodi': line.nodi,
					'archi': line.archi
				};
			});

			var endPointsData = topEndPoints.concat(bottomEndPoints);
			var circle = bottomEndPoints.concat(topEndPoints[0]);
			//console.log(circle);

			// Generating the svg circle attributes
			var endPointsAttributtes = {
				'width': 20,
				'height': 20,
				'x': function(d) {
					return d.x-10;
				},
				'y': function(d) {
					return d.y-10;
				},
				'fill': 'lightsteelblue'
			};

			// Pointer to d3 circles
			var endPoints = svg
			.selectAll('.rect')
			.data(circle);

			endPoints.exit().remove();

			endPoints.enter()
			.append('rect')
			.attr("class", "rect")
			.attr(endPointsAttributtes)
			.on("mouseover", handleMouseOver)
			.on("mouseout", handleMouseOut)
			.on("click", showCluster)
			.append("xhtml:div").attr("style", "width:190px; height:90px; overflow-y:auto").text("Thiggfis the dgdexsgsggs wish to fit insidegssgsgs");

			endPoints.attr(endPointsAttributtes);

			// testo
			var endPointsText = svg
			.selectAll('.text')
			.data(circle);

			//rimozione
			endPointsText.exit().remove();

			//creazione
			endPointsText.enter()
			.append('text')
			.attr("class", "text")
			.text(function(d){
				return d.nodi;
			})
			.attr("text-anchor", "end")
			.attr('x', function(d){
				return d.x;
			})
			.attr('y', function(d){
				return d.y-10;
			})
            .attr('fill', 'black');

            //aggiornamento
			endPoints.text(function(d){
				return d.nodi;
			})
			.attr('x', function(d){
				return d.x;
			})
			.attr('y', function(d){
				return d.y-10;
			});
			
			function handleMouseOver(d, i) {  // Add interactivite
				  
			    d3.select(this).attr({
		          fill: "orange"
		        });

		        // Specify where to put label of text
		        svg.append("text").attr({
		           id: "t" + d.x + "-" + d.y + "-" + i,  // Create an id for text so we can select it later for removing on mouseout
		            x: function() { return d.x - 5; },
		            y: function() { return d.y - 20; }
		        })
		        .text(function() {
		          //return [d.x, d.y];  // Value of the text
		          //console.log(d);
		          return [d.nodi];
		        });
		    }
				  
			function handleMouseOut(d, i) {
		        // Use D3 to select element, change color back to normal
		        d3.select(this).attr({
		          fill: "lightsteelblue",
		          r: rad
		        });

		        // Select text by id and then remove
		        d3.select("#t" + d.x + "-" + d.y + "-" + i).remove();  // Remove text location
		    }

		    function showCluster(d, i) {
		    	d3.select("#t" + d.x + "-" + d.y + "-" + i).remove();
		    	if(d.nodi>0){
		    		graphGen(d.archi);
		    	}
		    	console.log(d);
		    }
		};

	</script>
</body>
</html>